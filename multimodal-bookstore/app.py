import os
import io
import base64
import random
import re
import uuid
import requests
from PIL import Image
from flask import Flask, render_template, request, jsonify, session
from flask_pymongo import PyMongo
from dotenv import load_dotenv
import secrets
from datetime import timedelta
from bson import ObjectId
from difflib import get_close_matches
from werkzeug.utils import secure_filename

# ================== CONFIG ==================
load_dotenv()
OPENROUTER_API_KEY = os.environ.get("OPENROUTER_API_KEY")
# ƒê·∫£m b·∫£o b·∫°n ƒë√£ c·∫•u h√¨nh MONGO_URI v√† CLIP_API_URL trong .env
MONGO_URI = os.environ.get("MONGO_URI")
CLIP_API_URL = os.environ.get("CLIP_API_URL")  # URL CLIP API

app = Flask(__name__, static_folder="static", template_folder="templates")
app.secret_key = secrets.token_hex(16)
app.config["MONGO_URI"] = MONGO_URI
app.config["SESSION_PERMANENT"] = False
mongo = PyMongo(app)

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
UPLOAD_FOLDER = os.path.join(BASE_DIR, "static", "uploads")
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
# ================== UTILS ==================
def image_from_base64(data_url):
    """Gi·∫£i m√£ chu·ªói base64 th√†nh ƒë·ªëi t∆∞·ª£ng PIL Image."""
    if "," in data_url:
        _, b64 = data_url.split(",", 1)
    else:
        b64 = data_url
    return Image.open(io.BytesIO(base64.b64decode(b64)))
    
def find_book_by_title(text_query, books):
    """
    T√¨m s√°ch b·∫±ng ti√™u ƒë·ªÅ s·ª≠ d·ª•ng 3 chi·∫øn l∆∞·ª£c:
    1. Regex (kh√¥ng ph√¢n bi·ªát hoa th∆∞·ªùng)
    2. Fuzzy match to√†n b·ªô ti√™u ƒë·ªÅ
    3. Fuzzy match t·ª´ng t·ª´ trong truy v·∫•n
    """
    query_lower = text_query.lower()

    # 1. Regex tr·ª±c ti·∫øp (kh√¥ng ph√¢n bi·ªát hoa th∆∞·ªùng)
    # T√¨m ki·∫øm trong DB, kh√¥ng ph·∫£i trong list books ƒë√£ load.
    book_match = mongo.db.books.find_one({
        "title": {"$regex": text_query, "$options": "i"}
    })
    if book_match:
        return book_match

    # Chu·∫©n b·ªã danh s√°ch title (lowercase ƒë·ªÉ fuzzy match)
    all_titles = [b["title"] for b in books]
    all_titles_lower = [t.lower() for t in all_titles]

    # 2. Fuzzy match to√†n b·ªô t√™n
    close = get_close_matches(query_lower, all_titles_lower, n=1, cutoff=0.6)
    if close:
        # t√¨m l·∫°i t√™n g·ªëc kh·ªõp lowercase
        idx = all_titles_lower.index(close[0])
        return mongo.db.books.find_one({"title": all_titles[idx]})

    # 3. Fuzzy match t·ª´ng t·ª´
    words = query_lower.split()
    candidates = []
    for word in words:
        close_word = get_close_matches(word, all_titles_lower, n=3, cutoff=0.6)
        candidates.extend(close_word)

    if candidates:
        # ch·ªçn t√™n xu·∫•t hi·ªán nhi·ªÅu nh·∫•t
        best_guess = max(set(candidates), key=candidates.count)
        idx = all_titles_lower.index(best_guess)
        return mongo.db.books.find_one({"title": all_titles[idx]})

    return None
    
def make_json_safe(obj):
    """Chuy·ªÉn ƒë·ªïi c√°c ƒë·ªëi t∆∞·ª£ng kh√¥ng an to√†n cho JSON (nh∆∞ ObjectId) th√†nh chu·ªói."""
    if isinstance(obj, dict):
        return {k: make_json_safe(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [make_json_safe(i) for i in obj]
    elif isinstance(obj, (str, int, float, bool)) or obj is None:
        return obj
    else:
        return str(obj)

def get_session_data():
    """L·∫•y d·ªØ li·ªáu phi√™n (session data)."""
    if "data" not in session:
        session["data"] = {}
    return session["data"]

def save_session_data(data):
    """L∆∞u d·ªØ li·ªáu v√†o phi√™n."""
    session["data"] = data

def clear_session_data():
    """X√≥a to√†n b·ªô session."""
    session.clear()

def get_session_history():
    """L·∫•y l·ªãch s·ª≠ h·ªôi tho·∫°i, kh·ªüi t·∫°o n·∫øu ch∆∞a c√≥."""
    if "history" not in session:
        session["history"] = [
            {
                "role": "system",
                "content": (
                    "B·∫°n l√† tr·ª£ l√Ω AI c·ªßa c·ª≠a h√†ng BooksLand, nhi·ªám v·ª• h·ªó tr·ª£ kh√°ch h√†ng t√¨m s√°ch, "
                    "gi·ªõi thi·ªáu s·∫£n ph·∫©m v√† tr·∫£ l·ªùi th√¢n thi·ªán, s√∫c t√≠ch. Lu√¥n x∆∞ng l√† tr·ª£ l√Ω BooksLand."
                )
            }
        ]
    return session["history"]

def add_to_history(role, content):
    """Th√™m tin nh·∫Øn v√†o l·ªãch s·ª≠ h·ªôi tho·∫°i."""
    history = get_session_history()
    history.append({"role": role, "content": content})
    session["history"] = history

def call_openrouter(messages):
    """G·ªçi API OpenRouter (s·ª≠ d·ª•ng GPT-4o-mini)."""
    if not OPENROUTER_API_KEY:
        raise Exception("‚ö†Ô∏è Ch∆∞a c√≥ OPENROUTER_API_KEY trong .env")
    url = "https://openrouter.ai/api/v1/chat/completions"
    headers = {
        "Authorization": f"Bearer {OPENROUTER_API_KEY}",
        "Content-Type": "application/json",
    }
    payload = {"model": "openai/gpt-4o-mini", "messages": messages}
    r = requests.post(url, headers=headers, json=payload, timeout=30)
    r.raise_for_status()
    return r.json()

def generate_llm_reply_for_book(intent, book_data, session_history):
    """
    S·ª≠ d·ª•ng LLM ƒë·ªÉ t·∫°o ra ph·∫£n h·ªìi th√¢n thi·ªán, t·ª± nhi√™n d·ª±a tr√™n ng·ªØ c·∫£nh.
    :param intent: M·ª•c ƒë√≠ch c·ªßa ng∆∞·ªùi d√πng ('price', 'in_stock', 'general_info').
    :param book_data: D·ªØ li·ªáu cu·ªën s√°ch ƒë∆∞·ª£c t√¨m th·∫•y.
    :param session_history: L·ªãch s·ª≠ h·ªôi tho·∫°i (ƒë·ªÉ LLM hi·ªÉu ng·ªØ c·∫£nh).
    :return: C√¢u tr·∫£ l·ªùi do LLM t·∫°o.
    """
    book_title = book_data.get('title', 'm·ªôt cu·ªën s√°ch')
    book_author = book_data.get('author', 'kh√¥ng r√µ t√°c gi·∫£')
    book_description = book_data.get('description', 'kh√¥ng c√≥ m√¥ t·∫£ chi ti·∫øt')
    book_price = book_data.get('price', 'ch∆∞a c√≥ gi√°')

    # X√¢y d·ª±ng prompt cho LLM
    system_prompt = session_history[0]['content'] # Gi·ªØ nguy√™n system role c≈©
    
    # Chu·∫©n b·ªã context v·ªÅ s√°ch
    book_context = f"""
    TH√îNG TIN S√ÅCH ƒê∆Ø·ª¢C T√åM TH·∫§Y:
    - T·ª±a ƒë·ªÅ: {book_title}
    - T√°c gi·∫£: {book_author}
    - Gi√°: {book_price}
    - M√¥ t·∫£ t√≥m t·∫Øt: {book_description[:200]}...
    - Tr·∫°ng th√°i: C√≥ s·∫µn trong ti·ªám.
    """
    
    # Chu·∫©n b·ªã y√™u c·∫ßu c·ª• th·ªÉ
    user_request = session_history[-1]['content']
    
    if intent == 'price':
        instruction = f"Ng∆∞·ªùi d√πng h·ªèi gi√° c·ªßa s√°ch '{book_title}'. D·ª±a tr√™n th√¥ng tin S√ÅCH ƒê∆Ø·ª¢C T√åM TH·∫§Y, h√£y t·∫°o ra m·ªôt c√¢u tr·∫£ l·ªùi th√¢n thi·ªán, **ƒë∆∞a ra th√¥ng tin gi√°**, v√† h·ªèi l·∫°i xem h·ªç c√≥ mu·ªën mua kh√¥ng."
    elif intent == 'in_stock':
        instruction = f"Ng∆∞·ªùi d√πng h·ªèi ti·ªám c√≥ s√°ch '{book_title}' kh√¥ng. D·ª±a tr√™n th√¥ng tin S√ÅCH ƒê∆Ø·ª¢C T√åM TH·∫§Y, h√£y x√°c nh·∫≠n s√°ch c√≥ s·∫µn, **gi·ªõi thi·ªáu s∆° l∆∞·ª£c v·ªÅ s√°ch (t√°c gi·∫£, n·ªôi dung t√≥m t·∫Øt)** v√† h·ªèi l·∫°i xem h·ªç c√≥ mu·ªën mua kh√¥ng."
    elif intent == 'general_info':
        # Y√™u c·∫ßu r√µ r√†ng b·∫Øt ƒë·∫ßu b·∫±ng c√¢u x√°c nh·∫≠n (nh∆∞ y√™u c·∫ßu c·ªßa b·∫°n)
        instruction = f"Ng∆∞·ªùi d√πng t√¨m ki·∫øm ho·∫∑c h·ªèi th√¥ng tin chung v·ªÅ s√°ch '{book_title}'. D·ª±a tr√™n th√¥ng tin S√ÅCH ƒê∆Ø·ª¢C T√åM TH·∫§Y, h√£y t√≥m t·∫Øt ng·∫Øn g·ªçn n·ªôi dung v√† h·ªèi kh√°ch c√≥ mu·ªën mua kh√¥ng. **B·∫Øt ƒë·∫ßu b·∫±ng c√¢u h·ªèi x√°c nh·∫≠n: 'C√≥ ph·∫£i b·∫°n ƒëang t√¨m cu·ªën...'**."
    else:
        instruction = f"Ng∆∞·ªùi d√πng v·ª´a g·ª≠i truy v·∫•n: '{user_request}'. D·ª±a tr√™n th√¥ng tin S√ÅCH ƒê∆Ø·ª¢C T√åM TH·∫§Y, h√£y t·∫°o ra m·ªôt ph·∫£n h·ªìi th√¢n thi·ªán, gi√†u th√¥ng tin v√† ph√π h·ª£p v·ªõi ng·ªØ c·∫£nh."

    
    # X√¢y d·ª±ng messages cho LLM
    llm_messages = [
        {"role": "system", "content": system_prompt + "\n" + book_context},
        {"role": "user", "content": instruction}
    ]
    
    # Th√™m l·ªãch s·ª≠ (t·ªëi ƒëa 3 l·∫ßn t∆∞∆°ng t√°c g·∫ßn nh·∫•t) ƒë·ªÉ LLM gi·ªØ ng·ªØ c·∫£nh
    for msg in session_history[-4:-1]: 
        llm_messages.append(msg)

    try:
        response = call_openrouter(llm_messages)
        return response["choices"][0]["message"]["content"]
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói khi g·ªçi OpenRouter/LLM: {e}")
        # Fallback c·ª©ng n·∫øu LLM l·ªói
        if intent == 'price':
            return f"üìö S√°ch '{book_title}' c·ªßa {book_author} c√≥ gi√° **{book_price}**. B·∫°n c√≥ mu·ªën mua kh√¥ng?"
        elif intent == 'in_stock':
            return f"‚úÖ C√≥ ·∫°. Trong ti·ªám c√≥ b√°n '{book_title}' c·ªßa {book_author}, n√≥i v·ªÅ {book_description[:50]}... B·∫°n c√≥ mu·ªën mua kh√¥ng?"
        else:
            # Fallback cho general_info
            return f"C√≥ ph·∫£i b·∫°n ƒëang t√¨m cu·ªën s√°ch t·ª±a ƒë·ªÅ '{book_title}' c·ªßa {book_author}? B·∫°n c√≥ mu·ªën mua kh√¥ng?"
def generate_llm_summary_all_books(all_books, session_history):
    """
    Sinh ph·∫£n h·ªìi th√¢n thi·ªán cho nhi·ªÅu s√°ch c√πng l√∫c.
    """
    # Chu·∫©n b·ªã context
    book_infos = []
    total_price = 0
    for match in all_books:
        info = f"- {match.get('title')} c·ªßa {match.get('author')} (gi√°: {match.get('price')} VND)"
        book_infos.append(info)
        total_price += match.get("price", 0)

    books_context = "\n".join(book_infos)
    summary_prompt = f"""
    T√¥i c√≥ danh s√°ch s√°ch sau ƒë√¢y:

    {books_context}

    T·ªïng gi√° c·ªßa t·∫•t c·∫£ s√°ch l√† {total_price} VND.

    H√£y vi·∫øt m·ªôt ƒëo·∫°n tr·∫£ l·ªùi t·ª± nhi√™n, th√¢n thi·ªán nh∆∞ con ng∆∞·ªùi, 
    gi·ªõi thi·ªáu c√°c cu·ªën s√°ch n√†y, nh·∫•n m·∫°nh t·ªïng gi√°,
    v√† g·ª£i √Ω kh√°ch xem c√≥ mu·ªën ch·ªçn mua cu·ªën n√†o kh√¥ng.
    """

    # G·ªçi LLM
    system_prompt = session_history[0]["content"] if session_history else "B·∫°n l√† nh√¢n vi√™n t∆∞ v·∫•n s√°ch th√¢n thi·ªán."
    llm_messages = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": summary_prompt}
    ]

    try:
        response = call_openrouter(llm_messages)
        return response["choices"][0]["message"]["content"]
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói khi g·ªçi OpenRouter/LLM: {e}")
        # fallback: t·ª± gh√©p chu·ªói
        return f"T√¨m th·∫•y {len(all_books)} cu·ªën s√°ch:\n{books_context}\nüëâ T·ªïng gi√°: {total_price} VND."

# ================== PUSH BOOKS TO CLIP ==================
def push_books_to_clip():
    """G·ª≠i to√†n b·ªô d·ªØ li·ªáu s√°ch l√™n CLIP API ƒë·ªÉ t·∫°o embedding ph·ª•c v·ª• t√¨m ki·∫øm."""
    if not CLIP_API_URL:
        print("‚ö†Ô∏è Ch∆∞a c·∫•u h√¨nh CLIP_API_URL, b·ªè qua push s√°ch")
        return
    try:
        # L·∫•y s√°ch t·ª´ Mongo (ch·ªâ l·∫•y id v√† title ƒë·ªÉ check)
        books = list(mongo.db.books.find({}, {"_id": 1, "title": 1}))
        if not books:
            print("‚ö†Ô∏è Mongo ch∆∞a c√≥ s√°ch, b·ªè qua push s√°ch l√™n CLIP")
            return
            
        # T·∫£i l·∫°i to√†n b·ªô d·ªØ li·ªáu s√°ch ƒë·ªÉ g·ª≠i l√™n CLIP
        full_books = list(mongo.db.books.find())
        for book in full_books:
            book["_id"] = str(book["_id"])
            
        resp = requests.post(CLIP_API_URL + "/clip-match-text",
                             json={"query": "dummy", "books": full_books}, timeout=120)
        
        if resp.status_code == 200:
            print(f"‚úÖ ƒê√£ push {len(full_books)} s√°ch l√™n CLIP API th√†nh c√¥ng")
        else:
            print(f"‚ö†Ô∏è L·ªói khi push s√°ch: {resp.status_code}, {resp.text[:200]}")
    except Exception as e:
        print(f"‚ö†Ô∏è Exception khi push s√°ch l√™n CLIP: {e}")

# Ch·ªâ ch·∫°y khi module ƒë∆∞·ª£c load
push_books_to_clip()

# ================== ROUTES ==================
@app.route("/api/query", methods=["POST"])
def api_query():
    pil_img = None
    text_query = ""
    top_matches = []   # ‚úÖ lu√¥n khai b√°o tr∆∞·ªõc ƒë·ªÉ tr√°nh l·ªói

    # ================== 0. Nh·∫≠n input ==================
    if request.is_json:
        body = request.get_json() or {}
        text_query = (body.get("query") or "").strip()
        if body.get("image"):
            pil_img = image_from_base64(body["image"]).convert("RGB")
    else:
        body = request.form
        text_query = (body.get("query") or "").strip()
        if "file" in request.files:
            pil_img = Image.open(request.files["file"].stream).convert("RGB")

    # ================== 1. Reset session ==================
    if text_query.lower() == "reset":
        clear_session_data()
        return jsonify({"ok": True, "reply": "Session ƒë√£ ƒë∆∞·ª£c reset."})

    # ================== 2. Ph√¢n lo·∫°i input ==================
    input_type = "unknown"
    if pil_img and text_query:
        input_type = "both"
    elif pil_img:
        input_type = "image"
    elif text_query:
        input_type = "text"

    # ================== 3. Load s√°ch t·ª´ Mongo ==================
    books = list(mongo.db.books.find())
    for book in books:
        book["_id"] = str(book["_id"])

    session_data = get_session_data()

    # ================== 4. Helper session ==================
    def update_session_if_new_book(book):
        last_match = session_data.get("last_best_match")
        if not last_match or str(last_match.get("_id")) != str(book.get("_id")):
            session_data["last_best_match"] = make_json_safe(book)
            save_session_data(session_data)

    # ================== 5. Greeting intent ==================
    greetings = ["hi", "hello", "ch√†o", "hey", "xin ch√†o"]
    if text_query.lower() in greetings:
        add_to_history("user", text_query)
        reply = "Ch√†o b·∫°n üëã! M√¨nh l√† tr·ª£ l√Ω BooksLand, c√≥ th·ªÉ gi√∫p b·∫°n t√¨m s√°ch ho·∫∑c gi·ªõi thi·ªáu s·∫£n ph·∫©m."
        add_to_history("assistant", reply)
        return jsonify({
            "ok": True, "reply": reply,
            "cover": None, "covers": [], "book": None, "suggested": []
        })

    # ================== 6. X·ª≠ l√Ω Text-only ==================
    if text_query and not pil_img:
        query_lower = text_query.lower()

        # --- X√°c nh·∫≠n "c√≥" ---
        confirm_words_yes = ["c√≥", "ƒë√∫ng r·ªìi", "ok", "mua", "chu·∫©n", "ph·∫£i"]
        if query_lower in confirm_words_yes:
            last_book = session_data.get("last_best_match")
            if last_book:
                book_in_store = find_book_by_title(text_query, books)
                if book_in_store:
                    book_in_store["_id"] = str(book_in_store["_id"])
                    add_to_history("user", text_query)
                    llm_reply = generate_llm_reply_for_book("in_stock", book_in_store, get_session_history()) 
                    add_to_history("assistant", llm_reply)
                    return jsonify({
                        "ok": True, "reply": llm_reply,
                        "cover": book_in_store.get("cover"),
                        "covers": [book_in_store.get("cover")] if book_in_store.get("cover") else [],
                        "book": make_json_safe(book_in_store), "suggested": []
                    })
            return jsonify({"ok": False, "reply": "B·∫°n mu·ªën mua s√°ch n√†o nh·ªâ? H√£y ch·ªçn l·∫°i nh√©."})

        # --- X√°c nh·∫≠n "kh√¥ng" ---
        confirm_words_no = ["kh√¥ng", "kh√¥ng mua", "kh√¥ng nha", "kh√¥ng nhe", "kh√¥ng ph·∫£i", "sai", "nh·∫ßm"]
        if query_lower in confirm_words_no:
            # L·∫•y random 3 cu·ªën trong DB
            random_books = list(mongo.db.books.aggregate([{"$sample": {"size": 3}}]))
            for b in random_books:
                b["_id"] = str(b["_id"])  # convert ObjectId -> str ƒë·ªÉ JSON safe

            reply = "Kh√¥ng sao üòä. B·∫°n th·ª≠ xem th√™m m·∫•y cu·ªën n√†y nh√©."

            # Update session
            session_data["last_suggested"] = [make_json_safe(b) for b in random_books]
            save_session_data(session_data)

            # Update history
            add_to_history("user", text_query)
            add_to_history("assistant", reply)

            return jsonify({
                "ok": True,
                "reply": reply,
                "cover": random_books[0].get("cover") if random_books else None,
                "covers": [b.get("cover") for b in random_books if b.get("cover")],
                "book": None,
                "suggested": random_books
            })

        # --- H·ªèi gi√° ---
        price_keywords = ["gi√°", "cost", "bao nhi√™u", "m·∫•y ti·ªÅn", "gi√° bao nhi√™u", "nhi√™u"]
        if any(word in query_lower for word in price_keywords):
            add_to_history("user", text_query)
            last_book = session_data.get("last_best_match")
            book_match = find_book_by_title(text_query, books)
            if book_match:
                book_match["_id"] = str(book_match["_id"])
                update_session_if_new_book(book_match)
                session_data["last_suggested"] = [make_json_safe(book_match)]
                save_session_data(session_data)
                reply = generate_llm_reply_for_book("price", book_match, get_session_history())
                add_to_history("assistant", reply)
                return jsonify({
                    "ok": True, "reply": reply,
                    "cover": book_match.get("cover"),
                    "covers": [book_match.get("cover")] if book_match.get("cover") else [],
                    "book": make_json_safe(book_match), "suggested": [book_match]
                })
            elif last_book:
                reply = generate_llm_reply_for_book("price", last_book, get_session_history())
                add_to_history("assistant", reply)
                return jsonify({
                    "ok": True, "reply": reply,
                    "cover": last_book.get("cover"),
                    "covers": [last_book.get("cover")] if last_book.get("cover") else [],
                    "book": make_json_safe(last_book), "suggested": [last_book]
                })
            else:
                reply = "Xin l·ªói, m√¨nh ch∆∞a t√¨m th·∫•y s√°ch n√†o g·∫ßn gi·ªëng ƒë·ªÉ b√°o gi√°."
                add_to_history("assistant", reply)
                return jsonify({"ok": False, "reply": reply})

        # --- H·ªèi c√≥ b√°n kh√¥ng ---
        if "c√≥ b√°n" in query_lower or "c√≥ s√°ch" in query_lower or "trong ti·ªám c√≥" in query_lower:
            add_to_history("user", text_query)
            book_match = find_book_by_title(text_query, books)
            if book_match:
                book_match["_id"] = str(book_match["_id"])
                update_session_if_new_book(book_match)
                reply = generate_llm_reply_for_book("in_stock", book_match, get_session_history())
                add_to_history("assistant", reply)
                return jsonify({
                    "ok": True, "reply": reply,
                    "cover": book_match.get("cover"),
                    "covers": [book_match.get("cover")] if book_match.get("cover") else [],
                    "book": make_json_safe(book_match), "suggested": []
                })

        # --- T√¨m theo m√†u b√¨a ---
        color_map = {
            "m√†u ƒë·ªè": "red", "b√¨a ƒë·ªè": "red",
            "m√†u xanh": "blue", "b√¨a xanh": "blue",
            "m√†u v√†ng": "yellow", "b√¨a v√†ng": "yellow",
            "m√†u tr·∫Øng": "white", "b√¨a tr·∫Øng": "white",
            "m√†u ƒëen": "black", "b√¨a ƒëen": "black",
            "m√†u cam": "orange", "m√†u t√≠m": "purple",
            "m√†u h·ªìng": "pink", "m√†u n√¢u": "brown",
            "m√†u x√°m": "gray"
        }
        detected_color = None
        for kw, eng in color_map.items():
            if kw in query_lower:
                detected_color = eng
                break

        if detected_color:
            add_to_history("user", text_query)
            try:
                print(f"-> G·ªçi CLIP API theo m√†u s·∫Øc: {detected_color}")
                resp = requests.post(
                    f"{CLIP_API_URL}/clip-match-color",
                    json={"color": detected_color},
                    timeout=60
                ).json()
                top_matches = resp.get("suggested", [])
            except Exception as e:
                print(f"‚ö†Ô∏è L·ªói khi g·ªçi CLIP API Color Search: {e}")
                top_matches = []

            if top_matches:
                best_match = top_matches[0]
                update_session_if_new_book(best_match)

                # L∆∞u danh s√°ch g·ª£i √Ω v√†o session
                session_data["last_suggested"] = [make_json_safe(b) for b in top_matches]
                save_session_data(session_data)

                # Danh s√°ch s√°ch k√®m gi√°
                book_list_str = "\n".join([
                    f"- **{b['title']}** ({b['author']}) ‚Üí {b.get('price', 0):,}‚Ç´"
                    for b in top_matches
                ])

                # T√≠nh t·ªïng gi√°
                total_price = sum(b.get("price", 0) for b in top_matches)

                reply = (
                    f"D·ª±a tr√™n y√™u c·∫ßu t√¨m s√°ch b√¨a **{detected_color}**, BooksLand g·ª£i √Ω:\n"
                    f"{book_list_str}\n"
                    f"üëâ **T·ªïng c·ªông: {total_price:,}‚Ç´**\n\n"
                    "B·∫°n mu·ªën m√¨nh gi·ªõi thi·ªáu chi ti·∫øt cu·ªën n√†o kh√¥ng?"
                )

                add_to_history("assistant", reply)

                return jsonify({
                    "ok": True,
                    "reply": reply,
                    "cover": best_match.get("cover"),
                    "covers": [b.get("cover") for b in top_matches if b.get("cover")],
                    "book": make_json_safe(best_match),
                    "suggested": top_matches,
                    "detected_color": detected_color,
                    "total_price": total_price
                })
            else:
                reply = f"Xin l·ªói, ch∆∞a t√¨m th·∫•y s√°ch b√¨a **{detected_color}**."
                add_to_history("assistant", reply)
                return jsonify({"ok": False, "reply": reply})

        # --- T√¨m ki·∫øm chung ---
        book_match = find_book_by_title(text_query, books)
        if book_match:
            add_to_history("user", text_query)
            book_match["_id"] = str(book_match["_id"])
            update_session_if_new_book(book_match)
            session_data["last_suggested"] = [make_json_safe(book_match)]
            save_session_data(session_data)
            reply = generate_llm_reply_for_book("general_info", book_match, get_session_history())
            add_to_history("assistant", reply)
            return jsonify({
                "ok": True, "reply": reply,
                "cover": book_match.get("cover"),
                "covers": [book_match.get("cover")] if book_match.get("cover") else [],
                "book": make_json_safe(book_match), "suggested": [book_match]
            })

        try:
            resp = requests.post(
                f"{CLIP_API_URL}/clip-match-multimodal-text",
                json={"query": text_query, "books": books},
                timeout=60
            ).json()
            top_matches = resp.get("matches", [])
        except Exception as e:
            print(f"‚ö†Ô∏è L·ªói khi g·ªçi CLIP API Multimodal Search: {e}")
            top_matches = []

        if top_matches:
            add_to_history("user", text_query)
            best_match = top_matches[0]
            update_session_if_new_book(best_match)
            session_data["last_suggested"] = [make_json_safe(best_match)]
            save_session_data(session_data)
            reply = generate_llm_reply_for_book("general_info", best_match, get_session_history())
            add_to_history("assistant", reply)
            return jsonify({
                "ok": True, "reply": reply,
                "cover": best_match.get("cover"),
                "covers": [best_match.get("cover")] if best_match.get("cover") else [],
                "book": make_json_safe(best_match), "suggested": [best_match]
            })

        reply = "Hi·ªán ch∆∞a c√≥ s√°ch ph√π h·ª£p."
        add_to_history("user", text_query)
        add_to_history("assistant", reply)
        return jsonify({"ok": False, "reply": reply})

    # ================== 7. X·ª≠ l√Ω Image / Both ==================
    if pil_img:
        try:
            payload = {"books": books}
            buffered = io.BytesIO()
            pil_img.save(buffered, format="JPEG")
            img_b64 = "data:image/jpeg;base64," + base64.b64encode(buffered.getvalue()).decode()
            payload["image"] = img_b64
            if text_query:
                payload["query"] = text_query
            resp = requests.post(f"{CLIP_API_URL}/clip-match-book", json=payload, timeout=60).json()
            all_matches = resp.get("matches", [])   # list c√°c crop
            print(all_matches)
        except Exception as e:
            print(f"‚ö†Ô∏è L·ªói khi g·ªçi CLIP API (Image): {e}")
            all_matches = []

        # gom t·∫•t c·∫£ matches t·ª´ m·ªçi crop
        all_filtered = all_matches

        if all_filtered:
            combined_reply = generate_llm_summary_all_books(all_filtered, get_session_history())
            add_to_history("assistant", combined_reply)

            return jsonify({
                "ok": True,
                "reply": combined_reply,
                "covers": [m.get("cover") for m in all_filtered if m.get("cover")],
                "books": [make_json_safe(m) for m in all_filtered],
                "suggested": all_filtered,
                "total_price": sum(m.get("price", 0) for m in all_filtered)
            })
        else:
            reply = "Kh√¥ng nh·∫≠n di·ªán ƒë∆∞·ª£c s√°ch t·ª´ ·∫£nh."
            add_to_history("user", f"[IMAGE] {text_query if text_query else '(T√¨m s√°ch qua ·∫£nh)'}")
            add_to_history("assistant", reply)
            return jsonify({"ok": False, "reply": reply})


    # ================== 8. Fallback ==================
    reply = "Kh√¥ng hi·ªÉu y√™u c·∫ßu, vui l√≤ng th·ª≠ l·∫°i v·ªõi text ho·∫∑c ·∫£nh."
    add_to_history("user", text_query)
    add_to_history("assistant", reply)
    return jsonify({
        "ok": False, "reply": reply,
        "cover": None, "covers": [], "book": None, "suggested": []
    })

# ================== API CLEAR SESSION ==================

@app.route("/debug-session")
def debug_session():
    """Endpoint ƒë·ªÉ ki·ªÉm tra session (ch·ªâ d√πng khi debug)."""
    return jsonify({"session": dict(session)})
    
@app.route("/api/session/clear", methods=["POST"])
def clear_session_api():
    """API ƒë·ªÉ x√≥a session."""
    clear_session_data()
    resp = jsonify({"ok": True, "msg": "Session ƒë√£ ƒë∆∞·ª£c reset."})
    resp.set_cookie("session", "", expires=0)  # xo√° cookie session
    return resp

@app.route("/")
def index():
    """Trang ch·ªß, x√≥a session khi load."""
    session.clear()
    books = list(mongo.db.books.find())
    return render_template("index.html", books=books)

@app.route("/api/books", methods=["GET"])
def get_books():
    """L·∫•y danh s√°ch to√†n b·ªô s√°ch."""
    books = list(mongo.db.books.find())
    for book in books:
        book["_id"] = str(book["_id"])
    return jsonify({"ok": True, "books": [make_json_safe(book) for book in books]})
# -------- Add book --------
@app.route("/api/add-book", methods=["POST"])
def api_add_book():
    title = request.form.get("new-title")
    author = request.form.get("new-author")
    price = request.form.get("new-price")
    cover = request.files.get("new-cover-file")
    cover_url = request.form.get("new-cover-url")
    print(request.form)
    if not title or not author:
        return jsonify({"ok": False, "message": "‚ùå Thi·∫øu ti√™u ƒë·ªÅ ho·∫∑c t√°c gi·∫£."}), 400

    if cover:
        filename = secure_filename(cover.filename)
        save_path = os.path.join(UPLOAD_FOLDER, filename)
        cover.save(save_path)
        cover_url = "/static/uploads/" + filename

    mongo.db.books.insert_one({
        "title": title,
        "author": author,
        "price": int(price) if price and price.isdigit() else 0,
        "cover": cover_url
    })

    return jsonify({"ok": True, "message": "‚úÖ Book added to MongoDB"})

@app.route("/api/recommended", methods=["GET"])
def get_recommended():
    """L·∫•y danh s√°ch s√°ch g·ª£i √Ω ng·∫´u nhi√™n."""
    books = list(mongo.db.books.find())
    recommended = random.sample(books, min(6, len(books)))
    for book in recommended:
        book["_id"] = str(book["_id"])
    return jsonify({"ok": True, "books": [make_json_safe(book) for book in recommended]})

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)